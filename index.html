<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Particle Field</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overflow: hidden;
            background: #0f0f13;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .content {
            position: relative;
            z-index: 2;
            pointer-events: none;
        }
        .particle-info {
            background: rgba(15, 15, 25, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .control-panel {
            background: rgba(15, 15, 25, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="text-white font-mono">
    <canvas id="particleCanvas"></canvas>
    
    <div class="content min-h-screen flex flex-col justify-between p-4 md:p-8">
        <header class="flex justify-between items-start">
            <div class="particle-info p-4 rounded-lg max-w-md">
                <h1 class="text-2xl md:text-3xl font-bold mb-2">Quantum Particle Field</h1>
                <p class="text-sm md:text-base opacity-80">An emergent system of 1,024 interacting particles with physics-based behaviors.</p>
            </div>
            
            <div class="control-panel p-4 rounded-lg text-right">
                <div class="flex items-center space-x-4 mb-2">
                    <span class="text-sm opacity-70">Particles: <span id="particleCount">1024</span></span>
                    <button id="resetBtn" class="px-3 py-1 bg-white bg-opacity-10 rounded hover:bg-opacity-20 transition pointer-events-auto">Reset</button>
                </div>
                <div class="text-xs opacity-60">Move your cursor to interact</div>
            </div>
        </header>
        
        <footer class="flex justify-between items-end">
            <div class="particle-info p-4 rounded-lg max-w-md">
                <h2 class="text-lg font-semibold mb-1">System Metrics</h2>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div>Entropy: <span id="entropyValue">0.00</span></div>
                    <div>Energy: <span id="energyValue">0.00</span></div>
                    <div>Mean Velocity: <span id="velocityValue">0.00</span></div>
                    <div>Interactions: <span id="interactionValue">0</span></div>
                </div>
            </div>
            
            <div class="text-xs opacity-40">
                <div>Algorithm: Barnes-Hut approximation</div>
                <div>Î¸ = 0.5 | G = 6.674</div>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');
            const resetBtn = document.getElementById('resetBtn');
            
            // Metrics elements
            const entropyEl = document.getElementById('entropyValue');
            const energyEl = document.getElementById('energyValue');
            const velocityEl = document.getElementById('velocityValue');
            const interactionEl = document.getElementById('interactionValue');
            
            // Set canvas to full window size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Physics parameters
            const params = {
                particleCount: 1024,
                mouseInfluence: 0.5,
                mouseRadius: 150,
                repulsionForce: 0.8,
                friction: 0.95,
                springFactor: 0.01,
                timeStep: 0.5,
                theta: 0.5,
                gravitationalConstant: 6.674
            };
            
            // System state
            const state = {
                particles: [],
                mouse: { x: null, y: null, vx: 0, vy: 0 },
                lastTime: 0,
                frameCount: 0,
                interactions: 0,
                entropy: 0,
                energy: 0,
                meanVelocity: 0
            };
            
            // Particle class
            class Particle {
                constructor(x, y) {
                    this.x = x || Math.random() * canvas.width;
                    this.y = y || Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.ax = 0;
                    this.ay = 0;
                    this.mass = 0.5 + Math.random() * 1.5;
                    this.radius = 1 + this.mass * 1.5;
                    this.color = this.getColor();
                    this.connections = [];
                }
                
                getColor() {
                    const hue = (this.x / canvas.width * 60 + 200) % 360;
                    const sat = 70 + Math.random() * 30;
                    const light = 50 + Math.random() * 20;
                    return `hsl(${hue}, ${sat}%, ${light}%)`;
                }
                
                update(dt) {
                    // Apply velocity
                    this.vx += this.ax * dt;
                    this.vy += this.ay * dt;
                    
                    // Apply friction
                    this.vx *= params.friction;
                    this.vy *= params.friction;
                    
                    // Update position
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    
                    // Reset acceleration
                    this.ax = 0;
                    this.ay = 0;
                    
                    // Boundary conditions (elastic)
                    if (this.x < 0) {
                        this.x = 0;
                        this.vx *= -0.8;
                    } else if (this.x > canvas.width) {
                        this.x = canvas.width;
                        this.vx *= -0.8;
                    }
                    
                    if (this.y < 0) {
                        this.y = 0;
                        this.vy *= -0.8;
                    } else if (this.y > canvas.height) {
                        this.y = canvas.height;
                        this.vy *= -0.8;
                    }
                }
                
                applyForce(fx, fy) {
                    this.ax += fx / this.mass;
                    this.ay += fy / this.mass;
                }
            }
            
            // QuadTree implementation for efficient force calculation
            class QuadTree {
                constructor(boundary, capacity) {
                    this.boundary = boundary;
                    this.capacity = capacity;
                    this.particles = [];
                    this.divided = false;
                    this.mass = 0;
                    this.massCenter = { x: 0, y: 0 };
                }
                
                insert(particle) {
                    if (!this.boundary.contains(particle)) return false;
                    
                    if (this.particles.length < this.capacity) {
                        this.particles.push(particle);
                        
                        // Update mass center
                        const totalMass = this.mass + particle.mass;
                        this.massCenter.x = (this.massCenter.x * this.mass + particle.x * particle.mass) / totalMass;
                        this.massCenter.y = (this.massCenter.y * this.mass + particle.y * particle.mass) / totalMass;
                        this.mass = totalMass;
                        
                        return true;
                    }
                    
                    if (!this.divided) this.subdivide();
                    
                    return this.northeast.insert(particle) || 
                           this.northwest.insert(particle) || 
                           this.southeast.insert(particle) || 
                           this.southwest.insert(particle);
                }
                
                subdivide() {
                    const x = this.boundary.x;
                    const y = this.boundary.y;
                    const w = this.boundary.w / 2;
                    const h = this.boundary.h / 2;
                    
                    const ne = new Boundary(x + w, y, w, h);
                    const nw = new Boundary(x, y, w, h);
                    const se = new Boundary(x + w, y + h, w, h);
                    const sw = new Boundary(x, y + h, w, h);
                    
                    this.northeast = new QuadTree(ne, this.capacity);
                    this.northwest = new QuadTree(nw, this.capacity);
                    this.southeast = new QuadTree(se, this.capacity);
                    this.southwest = new QuadTree(sw, this.capacity);
                    
                    this.divided = true;
                    
                    // Re-insert particles into subdivisions
                    for (const p of this.particles) {
                        this.northeast.insert(p) || 
                        this.northwest.insert(p) || 
                        this.southeast.insert(p) || 
                        this.southwest.insert(p);
                    }
                    
                    this.particles = [];
                }
                
                query(range, found = []) {
                    if (!this.boundary.intersects(range)) return found;
                    
                    if (this.divided) {
                        this.northeast.query(range, found);
                        this.northwest.query(range, found);
                        this.southeast.query(range, found);
                        this.southwest.query(range, found);
                    } else {
                        for (const p of this.particles) {
                            if (range.contains(p)) found.push(p);
                        }
                    }
                    
                    return found;
                }
                
                // Calculate forces using Barnes-Hut approximation
                calculateForces(particle, theta) {
                    if (!this.boundary.contains(particle) && !this.boundary.intersectsCircle(particle, 100)) return;
                    
                    // If this node is external and contains the particle, skip
                    if (!this.divided && this.particles.includes(particle)) return;
                    
                    // Calculate distance to mass center
                    const dx = this.massCenter.x - particle.x;
                    const dy = this.massCenter.y - particle.y;
                    const distanceSq = dx * dx + dy * dy;
                    const distance = Math.sqrt(distanceSq);
                    
                    // If the node is sufficiently far away, treat it as a single body
                    const s = this.boundary.w; // Width of the cell
                    if (s / distance < theta && distance > 0) {
                        // Calculate gravitational force
                        const force = params.gravitationalConstant * particle.mass * this.mass / distanceSq;
                        const fx = (dx / distance) * force * 0.001;
                        const fy = (dy / distance) * force * 0.001;
                        
                        particle.applyForce(fx, fy);
                        state.interactions++;
                    } else if (this.divided) {
                        // Otherwise, recurse into children
                        this.northeast.calculateForces(particle, theta);
                        this.northwest.calculateForces(particle, theta);
                        this.southeast.calculateForces(particle, theta);
                        this.southwest.calculateForces(particle, theta);
                    } else {
                        // Calculate forces with individual particles
                        for (const p of this.particles) {
                            if (p === particle) continue;
                            
                            const dx = p.x - particle.x;
                            const dy = p.y - particle.y;
                            const distanceSq = dx * dx + dy * dy;
                            const distance = Math.sqrt(distanceSq);
                            
                            if (distance > 0 && distance < 100) {
                                // Repulsive force
                                const force = params.repulsionForce * particle.mass * p.mass / distanceSq;
                                const fx = (dx / distance) * force * -1;
                                const fy = (dy / distance) * force * -1;
                                
                                particle.applyForce(fx, fy);
                                state.interactions++;
                                
                                // Spring-like connections for nearby particles
                                if (distance < 30) {
                                    const springForce = (30 - distance) * params.springFactor;
                                    particle.applyForce(-dx * springForce, -dy * springForce);
                                    p.applyForce(dx * springForce, dy * springForce);
                                    
                                    // Store connection for drawing
                                    if (!particle.connections.includes(p)) {
                                        particle.connections.push(p);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Boundary class for QuadTree
            class Boundary {
                constructor(x, y, w, h) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                }
                
                contains(particle) {
                    return particle.x >= this.x - this.w &&
                           particle.x <= this.x + this.w &&
                           particle.y >= this.y - this.h &&
                           particle.y <= this.y + this.h;
                }
                
                intersects(range) {
                    return !(range.x - range.w > this.x + this.w ||
                             range.x + range.w < this.x - this.w ||
                             range.y - range.h > this.y + this.h ||
                             range.y + range.h < this.y - this.h);
                }
                
                intersectsCircle(particle, radius) {
                    const closestX = Math.max(this.x - this.w, Math.min(particle.x, this.x + this.w));
                    const closestY = Math.max(this.y - this.h, Math.min(particle.y, this.y + this.h));
                    
                    const dx = particle.x - closestX;
                    const dy = particle.y - closestY;
                    
                    return (dx * dx + dy * dy) <= (radius * radius);
                }
            }
            
            // Initialize particles
            function initParticles() {
                state.particles = [];
                state.interactions = 0;
                
                for (let i = 0; i < params.particleCount; i++) {
                    state.particles.push(new Particle());
                }
            }
            
            // Mouse interaction
            function handleMouseMove(e) {
                state.mouse.x = e.clientX;
                state.mouse.y = e.clientY;
                
                // Calculate mouse velocity
                if (state.mouse.lastX && state.mouse.lastY) {
                    state.mouse.vx = e.clientX - state.mouse.lastX;
                    state.mouse.vy = e.clientY - state.mouse.lastY;
                }
                
                state.mouse.lastX = e.clientX;
                state.mouse.lastY = e.clientY;
            }
            
            function handleMouseLeave() {
                state.mouse.x = null;
                state.mouse.y = null;
            }
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', handleMouseLeave);
            
            // Reset simulation
            resetBtn.addEventListener('click', initParticles);
            
            // Calculate system metrics
            function calculateMetrics() {
                // Calculate entropy (positional disorder)
                let positionVariance = 0;
                let totalVelocity = 0;
                let totalEnergy = 0;
                
                const meanX = canvas.width / 2;
                const meanY = canvas.height / 2;
                
                for (const p of state.particles) {
                    positionVariance += Math.sqrt((p.x - meanX) ** 2 + (p.y - meanY) ** 2);
                    totalVelocity += Math.sqrt(p.vx ** 2 + p.vy ** 2);
                    totalEnergy += 0.5 * p.mass * (p.vx ** 2 + p.vy ** 2);
                }
                
                state.entropy = (positionVariance / state.particles.length) / Math.sqrt(canvas.width ** 2 + canvas.height ** 2);
                state.meanVelocity = totalVelocity / state.particles.length;
                state.energy = totalEnergy;
                
                // Update UI
                entropyEl.textContent = state.entropy.toFixed(4);
                energyEl.textContent = state.energy.toFixed(2);
                velocityEl.textContent = state.meanVelocity.toFixed(2);
                interactionEl.textContent = state.interactions;
            }
            
            // Main animation loop
            function animate(timestamp) {
                if (!state.lastTime) state.lastTime = timestamp;
                const deltaTime = Math.min((timestamp - state.lastTime) / 1000, 0.1) * params.timeStep;
                state.lastTime = timestamp;
                state.frameCount++;
                
                // Clear canvas with semi-transparent background for motion blur effect
                ctx.fillStyle = 'rgba(15, 15, 25, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Create QuadTree
                const boundary = new Boundary(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height);
                const quadTree = new QuadTree(boundary, 4);
                
                // Insert particles into QuadTree
                for (const p of state.particles) {
                    quadTree.insert(p);
                    p.connections = []; // Reset connections
                }
                
                // Calculate forces
                state.interactions = 0;
                for (const p of state.particles) {
                    quadTree.calculateForces(p, params.theta);
                    
                    // Mouse interaction
                    if (state.mouse.x !== null && state.mouse.y !== null) {
                        const dx = state.mouse.x - p.x;
                        const dy = state.mouse.y - p.y;
                        const distanceSq = dx * dx + dy * dy;
                        const distance = Math.sqrt(distanceSq);
                        
                        if (distance < params.mouseRadius) {
                            const force = params.mouseInfluence * (1 - distance / params.mouseRadius);
                            p.applyForce(
                                dx / distance * force * 10,
                                dy / distance * force * 10
                            );
                            
                            // Add mouse velocity influence
                            p.applyForce(
                                state.mouse.vx * force * 0.1,
                                state.mouse.vy * force * 0.1
                            );
                        }
                    }
                }
                
                // Update particles
                for (const p of state.particles) {
                    p.update(deltaTime);
                }
                
                // Draw connections first (behind particles)
                ctx.lineWidth = 0.3;
                for (const p of state.particles) {
                    for (const other of p.connections) {
                        const dx = other.x - p.x;
                        const dy = other.y - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 30) {
                            const opacity = 1 - distance / 30;
                            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.2})`;
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(other.x, other.y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw particles
                for (const p of state.particles) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    
                    // Draw velocity vector
                    if (state.frameCount % 10 === 0) {
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x + p.vx * 5, p.y + p.vy * 5);
                        ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
                
                // Calculate and display metrics every 10 frames
                if (state.frameCount % 10 === 0) {
                    calculateMetrics();
                }
                
                requestAnimationFrame(animate);
            }
            
            // Start simulation
            initParticles();
            animate();
        });
    </script>
</body>
</html>
